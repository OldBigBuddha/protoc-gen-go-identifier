package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	identifierv1 "github.com/OldBigBuddha/protoc-gen-go-identifier/v1"
)

// identifierInfo holds extracted information about an identifier message.
type identifierInfo struct {
	Message   *protogen.Message
	Field     *protogen.Field
	Options   *identifierv1.IdentifierOptions
	GoType    string
	ZeroValue string
	IsBytes   bool
}

// generateFile processes a single proto file and generates identifier helpers.
func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	var identifiers []*identifierInfo

	// Scan all messages (including nested) for identifier option
	for _, msg := range file.Messages {
		if err := collectIdentifiers(msg, &identifiers); err != nil {
			return fmt.Errorf("file %s: %w", file.Desc.Path(), err)
		}
	}

	if len(identifiers) == 0 {
		return nil // No identifier messages in this file
	}

	// Generate output file
	filename := file.GeneratedFilenamePrefix + "_identifier.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateHeader(g, file, identifiers)
	for _, id := range identifiers {
		generateIdentifierMethods(g, id)
	}

	return nil
}

// collectIdentifiers recursively collects identifier messages.
func collectIdentifiers(msg *protogen.Message, identifiers *[]*identifierInfo) error {
	if hasIdentifierOption(msg) {
		info, err := extractIdentifierInfo(msg)
		if err != nil {
			return err
		}
		*identifiers = append(*identifiers, info)
	}

	// Check nested messages
	for _, nested := range msg.Messages {
		if err := collectIdentifiers(nested, identifiers); err != nil {
			return err
		}
	}

	return nil
}

// hasIdentifierOption checks if a message has the identifier option set.
func hasIdentifierOption(msg *protogen.Message) bool {
	opts := msg.Desc.Options()
	if opts == nil {
		return false
	}
	return proto.HasExtension(opts, identifierv1.E_Identifier)
}

// getIdentifierOption retrieves the identifier option from a message.
func getIdentifierOption(msg *protogen.Message) *identifierv1.IdentifierOptions {
	opts := msg.Desc.Options()
	if opts == nil {
		return &identifierv1.IdentifierOptions{}
	}
	ext := proto.GetExtension(opts, identifierv1.E_Identifier)
	if ext == nil {
		return &identifierv1.IdentifierOptions{}
	}
	return ext.(*identifierv1.IdentifierOptions)
}

// extractIdentifierInfo validates and extracts information from an identifier message.
func extractIdentifierInfo(msg *protogen.Message) (*identifierInfo, error) {
	fields := msg.Fields

	if len(fields) == 0 {
		return nil, fmt.Errorf("message %s: identifier messages must have exactly 1 field, got 0",
			msg.GoIdent.GoName)
	}

	if len(fields) > 1 {
		return nil, fmt.Errorf("message %s: identifier messages must have exactly 1 field, got %d",
			msg.GoIdent.GoName, len(fields))
	}

	field := fields[0]

	goType, zeroValue, isBytes, err := getFieldTypeInfo(field)
	if err != nil {
		return nil, fmt.Errorf("message %s: %w", msg.GoIdent.GoName, err)
	}

	return &identifierInfo{
		Message:   msg,
		Field:     field,
		Options:   getIdentifierOption(msg),
		GoType:    goType,
		ZeroValue: zeroValue,
		IsBytes:   isBytes,
	}, nil
}

// getFieldTypeInfo returns Go type, zero value, and whether it's bytes for a field.
func getFieldTypeInfo(field *protogen.Field) (goType, zeroValue string, isBytes bool, err error) {
	if field.Desc.IsList() {
		return "", "", false, fmt.Errorf("field %s cannot be repeated", field.GoName)
	}
	if field.Desc.IsMap() {
		return "", "", false, fmt.Errorf("field %s cannot be a map", field.GoName)
	}

	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		return "string", `""`, false, nil
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32", "0", false, nil
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64", "0", false, nil
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32", "0", false, nil
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64", "0", false, nil
	case protoreflect.BytesKind:
		return "[]byte", "nil", true, nil
	default:
		return "", "", false, fmt.Errorf("field %s has unsupported type %s (must be scalar: string, intN, uintN, or bytes)",
			field.GoName, field.Desc.Kind())
	}
}

// generateHeader writes the file header and imports.
func generateHeader(g *protogen.GeneratedFile, file *protogen.File, identifiers []*identifierInfo) {
	g.P("// Code generated by protoc-gen-go-identifier. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Check if we need bytes import
	needsBytes := false
	for _, id := range identifiers {
		if id.IsBytes && !id.Options.GetSkipEqual() {
			needsBytes = true
			break
		}
	}

	g.P("import (")
	if needsBytes {
		g.P(`	"bytes"`)
	}
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()
}

// generateIdentifierMethods generates all helper methods for an identifier.
func generateIdentifierMethods(g *protogen.GeneratedFile, id *identifierInfo) {
	msgName := id.Message.GoIdent.GoName
	fieldName := id.Field.GoName
	goType := id.GoType
	zeroValue := id.ZeroValue
	opts := id.Options

	// Constructor: As<Type>()
	if !opts.GetSkipConstructor() {
		g.P("// As", msgName, " creates a new ", msgName, " from the given value.")
		g.P("func As", msgName, "(v ", goType, ") *", msgName, " {")
		g.P("	return &", msgName, "{", fieldName, ": v}")
		g.P("}")
		g.P()
	}

	// Unwrap()
	if !opts.GetSkipUnwrap() {
		g.P("// Unwrap returns the underlying value. Returns ", zeroValue, " if receiver is nil.")
		g.P("func (x *", msgName, ") Unwrap() ", goType, " {")
		g.P("	if x == nil {")
		g.P("		return ", zeroValue)
		g.P("	}")
		g.P("	return x.", fieldName)
		g.P("}")
		g.P()
	}

	// Equal()
	if !opts.GetSkipEqual() {
		g.P("// Equal reports whether x and other have the same underlying value.")
		g.P("func (x *", msgName, ") Equal(other *", msgName, ") bool {")
		if id.IsBytes {
			g.P("	return bytes.Equal(x.Unwrap(), other.Unwrap())")
		} else {
			g.P("	return x.Unwrap() == other.Unwrap()")
		}
		g.P("}")
		g.P()
	}

	// Clone()
	if !opts.GetSkipClone() {
		g.P("// Clone returns a deep copy of the ", msgName, ".")
		g.P("func (x *", msgName, ") Clone() *", msgName, " {")
		g.P("	return proto.Clone(x).(*", msgName, ")")
		g.P("}")
		g.P()
	}
}

